// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"
	"time"

	"github.com/pivotal-cf/bosh-backup-and-restore/orchestrator"
)

type FakeArtifact struct {
	CreateFileStub        func(orchestrator.ArtifactIdentifier) (io.WriteCloser, error)
	createFileMutex       sync.RWMutex
	createFileArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	createFileReturns struct {
		result1 io.WriteCloser
		result2 error
	}
	createFileReturnsOnCall map[int]struct {
		result1 io.WriteCloser
		result2 error
	}
	ReadFileStub        func(orchestrator.ArtifactIdentifier) (io.ReadCloser, error)
	readFileMutex       sync.RWMutex
	readFileArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	readFileReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	readFileReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	AddChecksumStub        func(orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) error
	addChecksumMutex       sync.RWMutex
	addChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}
	addChecksumReturns struct {
		result1 error
	}
	addChecksumReturnsOnCall map[int]struct {
		result1 error
	}
	CreateMetadataFileWithStartTimeStub        func(time.Time) error
	createMetadataFileWithStartTimeMutex       sync.RWMutex
	createMetadataFileWithStartTimeArgsForCall []struct {
		arg1 time.Time
	}
	createMetadataFileWithStartTimeReturns struct {
		result1 error
	}
	createMetadataFileWithStartTimeReturnsOnCall map[int]struct {
		result1 error
	}
	AddFinishTimeStub        func(time.Time) error
	addFinishTimeMutex       sync.RWMutex
	addFinishTimeArgsForCall []struct {
		arg1 time.Time
	}
	addFinishTimeReturns struct {
		result1 error
	}
	addFinishTimeReturnsOnCall map[int]struct {
		result1 error
	}
	FetchChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	fetchChecksumMutex       sync.RWMutex
	fetchChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	fetchChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	fetchChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	CalculateChecksumStub        func(orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error)
	calculateChecksumMutex       sync.RWMutex
	calculateChecksumArgsForCall []struct {
		arg1 orchestrator.ArtifactIdentifier
	}
	calculateChecksumReturns struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	calculateChecksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	DeploymentMatchesStub        func(string, []orchestrator.Instance) (bool, error)
	deploymentMatchesMutex       sync.RWMutex
	deploymentMatchesArgsForCall []struct {
		arg1 string
		arg2 []orchestrator.Instance
	}
	deploymentMatchesReturns struct {
		result1 bool
		result2 error
	}
	deploymentMatchesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SaveManifestStub        func(manifest string) error
	saveManifestMutex       sync.RWMutex
	saveManifestArgsForCall []struct {
		manifest string
	}
	saveManifestReturns struct {
		result1 error
	}
	saveManifestReturnsOnCall map[int]struct {
		result1 error
	}
	ValidStub        func() (bool, error)
	validMutex       sync.RWMutex
	validArgsForCall []struct{}
	validReturns     struct {
		result1 bool
		result2 error
	}
	validReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeArtifact) CreateFile(arg1 orchestrator.ArtifactIdentifier) (io.WriteCloser, error) {
	fake.createFileMutex.Lock()
	ret, specificReturn := fake.createFileReturnsOnCall[len(fake.createFileArgsForCall)]
	fake.createFileArgsForCall = append(fake.createFileArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("CreateFile", []interface{}{arg1})
	fake.createFileMutex.Unlock()
	if fake.CreateFileStub != nil {
		return fake.CreateFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createFileReturns.result1, fake.createFileReturns.result2
}

func (fake *FakeArtifact) CreateFileCallCount() int {
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	return len(fake.createFileArgsForCall)
}

func (fake *FakeArtifact) CreateFileArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	return fake.createFileArgsForCall[i].arg1
}

func (fake *FakeArtifact) CreateFileReturns(result1 io.WriteCloser, result2 error) {
	fake.CreateFileStub = nil
	fake.createFileReturns = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) CreateFileReturnsOnCall(i int, result1 io.WriteCloser, result2 error) {
	fake.CreateFileStub = nil
	if fake.createFileReturnsOnCall == nil {
		fake.createFileReturnsOnCall = make(map[int]struct {
			result1 io.WriteCloser
			result2 error
		})
	}
	fake.createFileReturnsOnCall[i] = struct {
		result1 io.WriteCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) ReadFile(arg1 orchestrator.ArtifactIdentifier) (io.ReadCloser, error) {
	fake.readFileMutex.Lock()
	ret, specificReturn := fake.readFileReturnsOnCall[len(fake.readFileArgsForCall)]
	fake.readFileArgsForCall = append(fake.readFileArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("ReadFile", []interface{}{arg1})
	fake.readFileMutex.Unlock()
	if fake.ReadFileStub != nil {
		return fake.ReadFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.readFileReturns.result1, fake.readFileReturns.result2
}

func (fake *FakeArtifact) ReadFileCallCount() int {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return len(fake.readFileArgsForCall)
}

func (fake *FakeArtifact) ReadFileArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	return fake.readFileArgsForCall[i].arg1
}

func (fake *FakeArtifact) ReadFileReturns(result1 io.ReadCloser, result2 error) {
	fake.ReadFileStub = nil
	fake.readFileReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) ReadFileReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ReadFileStub = nil
	if fake.readFileReturnsOnCall == nil {
		fake.readFileReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.readFileReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) AddChecksum(arg1 orchestrator.ArtifactIdentifier, arg2 orchestrator.BackupChecksum) error {
	fake.addChecksumMutex.Lock()
	ret, specificReturn := fake.addChecksumReturnsOnCall[len(fake.addChecksumArgsForCall)]
	fake.addChecksumArgsForCall = append(fake.addChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
		arg2 orchestrator.BackupChecksum
	}{arg1, arg2})
	fake.recordInvocation("AddChecksum", []interface{}{arg1, arg2})
	fake.addChecksumMutex.Unlock()
	if fake.AddChecksumStub != nil {
		return fake.AddChecksumStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addChecksumReturns.result1
}

func (fake *FakeArtifact) AddChecksumCallCount() int {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	return len(fake.addChecksumArgsForCall)
}

func (fake *FakeArtifact) AddChecksumArgsForCall(i int) (orchestrator.ArtifactIdentifier, orchestrator.BackupChecksum) {
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	return fake.addChecksumArgsForCall[i].arg1, fake.addChecksumArgsForCall[i].arg2
}

func (fake *FakeArtifact) AddChecksumReturns(result1 error) {
	fake.AddChecksumStub = nil
	fake.addChecksumReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) AddChecksumReturnsOnCall(i int, result1 error) {
	fake.AddChecksumStub = nil
	if fake.addChecksumReturnsOnCall == nil {
		fake.addChecksumReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addChecksumReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) CreateMetadataFileWithStartTime(arg1 time.Time) error {
	fake.createMetadataFileWithStartTimeMutex.Lock()
	ret, specificReturn := fake.createMetadataFileWithStartTimeReturnsOnCall[len(fake.createMetadataFileWithStartTimeArgsForCall)]
	fake.createMetadataFileWithStartTimeArgsForCall = append(fake.createMetadataFileWithStartTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("CreateMetadataFileWithStartTime", []interface{}{arg1})
	fake.createMetadataFileWithStartTimeMutex.Unlock()
	if fake.CreateMetadataFileWithStartTimeStub != nil {
		return fake.CreateMetadataFileWithStartTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createMetadataFileWithStartTimeReturns.result1
}

func (fake *FakeArtifact) CreateMetadataFileWithStartTimeCallCount() int {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	return len(fake.createMetadataFileWithStartTimeArgsForCall)
}

func (fake *FakeArtifact) CreateMetadataFileWithStartTimeArgsForCall(i int) time.Time {
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	return fake.createMetadataFileWithStartTimeArgsForCall[i].arg1
}

func (fake *FakeArtifact) CreateMetadataFileWithStartTimeReturns(result1 error) {
	fake.CreateMetadataFileWithStartTimeStub = nil
	fake.createMetadataFileWithStartTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) CreateMetadataFileWithStartTimeReturnsOnCall(i int, result1 error) {
	fake.CreateMetadataFileWithStartTimeStub = nil
	if fake.createMetadataFileWithStartTimeReturnsOnCall == nil {
		fake.createMetadataFileWithStartTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createMetadataFileWithStartTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) AddFinishTime(arg1 time.Time) error {
	fake.addFinishTimeMutex.Lock()
	ret, specificReturn := fake.addFinishTimeReturnsOnCall[len(fake.addFinishTimeArgsForCall)]
	fake.addFinishTimeArgsForCall = append(fake.addFinishTimeArgsForCall, struct {
		arg1 time.Time
	}{arg1})
	fake.recordInvocation("AddFinishTime", []interface{}{arg1})
	fake.addFinishTimeMutex.Unlock()
	if fake.AddFinishTimeStub != nil {
		return fake.AddFinishTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addFinishTimeReturns.result1
}

func (fake *FakeArtifact) AddFinishTimeCallCount() int {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	return len(fake.addFinishTimeArgsForCall)
}

func (fake *FakeArtifact) AddFinishTimeArgsForCall(i int) time.Time {
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	return fake.addFinishTimeArgsForCall[i].arg1
}

func (fake *FakeArtifact) AddFinishTimeReturns(result1 error) {
	fake.AddFinishTimeStub = nil
	fake.addFinishTimeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) AddFinishTimeReturnsOnCall(i int, result1 error) {
	fake.AddFinishTimeStub = nil
	if fake.addFinishTimeReturnsOnCall == nil {
		fake.addFinishTimeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFinishTimeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) FetchChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.fetchChecksumMutex.Lock()
	ret, specificReturn := fake.fetchChecksumReturnsOnCall[len(fake.fetchChecksumArgsForCall)]
	fake.fetchChecksumArgsForCall = append(fake.fetchChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("FetchChecksum", []interface{}{arg1})
	fake.fetchChecksumMutex.Unlock()
	if fake.FetchChecksumStub != nil {
		return fake.FetchChecksumStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchChecksumReturns.result1, fake.fetchChecksumReturns.result2
}

func (fake *FakeArtifact) FetchChecksumCallCount() int {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	return len(fake.fetchChecksumArgsForCall)
}

func (fake *FakeArtifact) FetchChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	return fake.fetchChecksumArgsForCall[i].arg1
}

func (fake *FakeArtifact) FetchChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.FetchChecksumStub = nil
	fake.fetchChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) FetchChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.FetchChecksumStub = nil
	if fake.fetchChecksumReturnsOnCall == nil {
		fake.fetchChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.fetchChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) CalculateChecksum(arg1 orchestrator.ArtifactIdentifier) (orchestrator.BackupChecksum, error) {
	fake.calculateChecksumMutex.Lock()
	ret, specificReturn := fake.calculateChecksumReturnsOnCall[len(fake.calculateChecksumArgsForCall)]
	fake.calculateChecksumArgsForCall = append(fake.calculateChecksumArgsForCall, struct {
		arg1 orchestrator.ArtifactIdentifier
	}{arg1})
	fake.recordInvocation("CalculateChecksum", []interface{}{arg1})
	fake.calculateChecksumMutex.Unlock()
	if fake.CalculateChecksumStub != nil {
		return fake.CalculateChecksumStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.calculateChecksumReturns.result1, fake.calculateChecksumReturns.result2
}

func (fake *FakeArtifact) CalculateChecksumCallCount() int {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	return len(fake.calculateChecksumArgsForCall)
}

func (fake *FakeArtifact) CalculateChecksumArgsForCall(i int) orchestrator.ArtifactIdentifier {
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	return fake.calculateChecksumArgsForCall[i].arg1
}

func (fake *FakeArtifact) CalculateChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.CalculateChecksumStub = nil
	fake.calculateChecksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) CalculateChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.CalculateChecksumStub = nil
	if fake.calculateChecksumReturnsOnCall == nil {
		fake.calculateChecksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.calculateChecksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) DeploymentMatches(arg1 string, arg2 []orchestrator.Instance) (bool, error) {
	var arg2Copy []orchestrator.Instance
	if arg2 != nil {
		arg2Copy = make([]orchestrator.Instance, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.deploymentMatchesMutex.Lock()
	ret, specificReturn := fake.deploymentMatchesReturnsOnCall[len(fake.deploymentMatchesArgsForCall)]
	fake.deploymentMatchesArgsForCall = append(fake.deploymentMatchesArgsForCall, struct {
		arg1 string
		arg2 []orchestrator.Instance
	}{arg1, arg2Copy})
	fake.recordInvocation("DeploymentMatches", []interface{}{arg1, arg2Copy})
	fake.deploymentMatchesMutex.Unlock()
	if fake.DeploymentMatchesStub != nil {
		return fake.DeploymentMatchesStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.deploymentMatchesReturns.result1, fake.deploymentMatchesReturns.result2
}

func (fake *FakeArtifact) DeploymentMatchesCallCount() int {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	return len(fake.deploymentMatchesArgsForCall)
}

func (fake *FakeArtifact) DeploymentMatchesArgsForCall(i int) (string, []orchestrator.Instance) {
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	return fake.deploymentMatchesArgsForCall[i].arg1, fake.deploymentMatchesArgsForCall[i].arg2
}

func (fake *FakeArtifact) DeploymentMatchesReturns(result1 bool, result2 error) {
	fake.DeploymentMatchesStub = nil
	fake.deploymentMatchesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) DeploymentMatchesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DeploymentMatchesStub = nil
	if fake.deploymentMatchesReturnsOnCall == nil {
		fake.deploymentMatchesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deploymentMatchesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) SaveManifest(manifest string) error {
	fake.saveManifestMutex.Lock()
	ret, specificReturn := fake.saveManifestReturnsOnCall[len(fake.saveManifestArgsForCall)]
	fake.saveManifestArgsForCall = append(fake.saveManifestArgsForCall, struct {
		manifest string
	}{manifest})
	fake.recordInvocation("SaveManifest", []interface{}{manifest})
	fake.saveManifestMutex.Unlock()
	if fake.SaveManifestStub != nil {
		return fake.SaveManifestStub(manifest)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveManifestReturns.result1
}

func (fake *FakeArtifact) SaveManifestCallCount() int {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	return len(fake.saveManifestArgsForCall)
}

func (fake *FakeArtifact) SaveManifestArgsForCall(i int) string {
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	return fake.saveManifestArgsForCall[i].manifest
}

func (fake *FakeArtifact) SaveManifestReturns(result1 error) {
	fake.SaveManifestStub = nil
	fake.saveManifestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) SaveManifestReturnsOnCall(i int, result1 error) {
	fake.SaveManifestStub = nil
	if fake.saveManifestReturnsOnCall == nil {
		fake.saveManifestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveManifestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeArtifact) Valid() (bool, error) {
	fake.validMutex.Lock()
	ret, specificReturn := fake.validReturnsOnCall[len(fake.validArgsForCall)]
	fake.validArgsForCall = append(fake.validArgsForCall, struct{}{})
	fake.recordInvocation("Valid", []interface{}{})
	fake.validMutex.Unlock()
	if fake.ValidStub != nil {
		return fake.ValidStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.validReturns.result1, fake.validReturns.result2
}

func (fake *FakeArtifact) ValidCallCount() int {
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	return len(fake.validArgsForCall)
}

func (fake *FakeArtifact) ValidReturns(result1 bool, result2 error) {
	fake.ValidStub = nil
	fake.validReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) ValidReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ValidStub = nil
	if fake.validReturnsOnCall == nil {
		fake.validReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.validReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeArtifact) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createFileMutex.RLock()
	defer fake.createFileMutex.RUnlock()
	fake.readFileMutex.RLock()
	defer fake.readFileMutex.RUnlock()
	fake.addChecksumMutex.RLock()
	defer fake.addChecksumMutex.RUnlock()
	fake.createMetadataFileWithStartTimeMutex.RLock()
	defer fake.createMetadataFileWithStartTimeMutex.RUnlock()
	fake.addFinishTimeMutex.RLock()
	defer fake.addFinishTimeMutex.RUnlock()
	fake.fetchChecksumMutex.RLock()
	defer fake.fetchChecksumMutex.RUnlock()
	fake.calculateChecksumMutex.RLock()
	defer fake.calculateChecksumMutex.RUnlock()
	fake.deploymentMatchesMutex.RLock()
	defer fake.deploymentMatchesMutex.RUnlock()
	fake.saveManifestMutex.RLock()
	defer fake.saveManifestMutex.RUnlock()
	fake.validMutex.RLock()
	defer fake.validMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeArtifact) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.Artifact = new(FakeArtifact)
