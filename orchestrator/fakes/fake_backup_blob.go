// This file was generated by counterfeiter
package fakes

import (
	"io"
	"sync"

	"github.com/pivotal-cf/bosh-backup-and-restore/orchestrator"
)

type FakeBackupBlob struct {
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	IndexStub        func() string
	indexMutex       sync.RWMutex
	indexArgsForCall []struct{}
	indexReturns     struct {
		result1 string
	}
	indexReturnsOnCall map[int]struct {
		result1 string
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	IsNamedStub        func() bool
	isNamedMutex       sync.RWMutex
	isNamedArgsForCall []struct{}
	isNamedReturns     struct {
		result1 bool
	}
	isNamedReturnsOnCall map[int]struct {
		result1 bool
	}
	SizeStub        func() (string, error)
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct{}
	sizeReturns     struct {
		result1 string
		result2 error
	}
	sizeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ChecksumStub        func() (orchestrator.BackupChecksum, error)
	checksumMutex       sync.RWMutex
	checksumArgsForCall []struct{}
	checksumReturns     struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	checksumReturnsOnCall map[int]struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}
	StreamFromRemoteStub        func(io.Writer) error
	streamFromRemoteMutex       sync.RWMutex
	streamFromRemoteArgsForCall []struct {
		arg1 io.Writer
	}
	streamFromRemoteReturns struct {
		result1 error
	}
	streamFromRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct{}
	deleteReturns     struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	StreamToRemoteStub        func(io.Reader) error
	streamToRemoteMutex       sync.RWMutex
	streamToRemoteArgsForCall []struct {
		arg1 io.Reader
	}
	streamToRemoteReturns struct {
		result1 error
	}
	streamToRemoteReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBackupBlob) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeBackupBlob) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeBackupBlob) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) Index() string {
	fake.indexMutex.Lock()
	ret, specificReturn := fake.indexReturnsOnCall[len(fake.indexArgsForCall)]
	fake.indexArgsForCall = append(fake.indexArgsForCall, struct{}{})
	fake.recordInvocation("Index", []interface{}{})
	fake.indexMutex.Unlock()
	if fake.IndexStub != nil {
		return fake.IndexStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.indexReturns.result1
}

func (fake *FakeBackupBlob) IndexCallCount() int {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	return len(fake.indexArgsForCall)
}

func (fake *FakeBackupBlob) IndexReturns(result1 string) {
	fake.IndexStub = nil
	fake.indexReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) IndexReturnsOnCall(i int, result1 string) {
	fake.IndexStub = nil
	if fake.indexReturnsOnCall == nil {
		fake.indexReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.indexReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeBackupBlob) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeBackupBlob) IDReturns(result1 string) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) IDReturnsOnCall(i int, result1 string) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeBackupBlob) IsNamed() bool {
	fake.isNamedMutex.Lock()
	ret, specificReturn := fake.isNamedReturnsOnCall[len(fake.isNamedArgsForCall)]
	fake.isNamedArgsForCall = append(fake.isNamedArgsForCall, struct{}{})
	fake.recordInvocation("IsNamed", []interface{}{})
	fake.isNamedMutex.Unlock()
	if fake.IsNamedStub != nil {
		return fake.IsNamedStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isNamedReturns.result1
}

func (fake *FakeBackupBlob) IsNamedCallCount() int {
	fake.isNamedMutex.RLock()
	defer fake.isNamedMutex.RUnlock()
	return len(fake.isNamedArgsForCall)
}

func (fake *FakeBackupBlob) IsNamedReturns(result1 bool) {
	fake.IsNamedStub = nil
	fake.isNamedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBackupBlob) IsNamedReturnsOnCall(i int, result1 bool) {
	fake.IsNamedStub = nil
	if fake.isNamedReturnsOnCall == nil {
		fake.isNamedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNamedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeBackupBlob) Size() (string, error) {
	fake.sizeMutex.Lock()
	ret, specificReturn := fake.sizeReturnsOnCall[len(fake.sizeArgsForCall)]
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct{}{})
	fake.recordInvocation("Size", []interface{}{})
	fake.sizeMutex.Unlock()
	if fake.SizeStub != nil {
		return fake.SizeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sizeReturns.result1, fake.sizeReturns.result2
}

func (fake *FakeBackupBlob) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeBackupBlob) SizeReturns(result1 string, result2 error) {
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupBlob) SizeReturnsOnCall(i int, result1 string, result2 error) {
	fake.SizeStub = nil
	if fake.sizeReturnsOnCall == nil {
		fake.sizeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.sizeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupBlob) Checksum() (orchestrator.BackupChecksum, error) {
	fake.checksumMutex.Lock()
	ret, specificReturn := fake.checksumReturnsOnCall[len(fake.checksumArgsForCall)]
	fake.checksumArgsForCall = append(fake.checksumArgsForCall, struct{}{})
	fake.recordInvocation("Checksum", []interface{}{})
	fake.checksumMutex.Unlock()
	if fake.ChecksumStub != nil {
		return fake.ChecksumStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checksumReturns.result1, fake.checksumReturns.result2
}

func (fake *FakeBackupBlob) ChecksumCallCount() int {
	fake.checksumMutex.RLock()
	defer fake.checksumMutex.RUnlock()
	return len(fake.checksumArgsForCall)
}

func (fake *FakeBackupBlob) ChecksumReturns(result1 orchestrator.BackupChecksum, result2 error) {
	fake.ChecksumStub = nil
	fake.checksumReturns = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupBlob) ChecksumReturnsOnCall(i int, result1 orchestrator.BackupChecksum, result2 error) {
	fake.ChecksumStub = nil
	if fake.checksumReturnsOnCall == nil {
		fake.checksumReturnsOnCall = make(map[int]struct {
			result1 orchestrator.BackupChecksum
			result2 error
		})
	}
	fake.checksumReturnsOnCall[i] = struct {
		result1 orchestrator.BackupChecksum
		result2 error
	}{result1, result2}
}

func (fake *FakeBackupBlob) StreamFromRemote(arg1 io.Writer) error {
	fake.streamFromRemoteMutex.Lock()
	ret, specificReturn := fake.streamFromRemoteReturnsOnCall[len(fake.streamFromRemoteArgsForCall)]
	fake.streamFromRemoteArgsForCall = append(fake.streamFromRemoteArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	fake.recordInvocation("StreamFromRemote", []interface{}{arg1})
	fake.streamFromRemoteMutex.Unlock()
	if fake.StreamFromRemoteStub != nil {
		return fake.StreamFromRemoteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.streamFromRemoteReturns.result1
}

func (fake *FakeBackupBlob) StreamFromRemoteCallCount() int {
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	return len(fake.streamFromRemoteArgsForCall)
}

func (fake *FakeBackupBlob) StreamFromRemoteArgsForCall(i int) io.Writer {
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	return fake.streamFromRemoteArgsForCall[i].arg1
}

func (fake *FakeBackupBlob) StreamFromRemoteReturns(result1 error) {
	fake.StreamFromRemoteStub = nil
	fake.streamFromRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) StreamFromRemoteReturnsOnCall(i int, result1 error) {
	fake.StreamFromRemoteStub = nil
	if fake.streamFromRemoteReturnsOnCall == nil {
		fake.streamFromRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamFromRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct{}{})
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeBackupBlob) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeBackupBlob) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) StreamToRemote(arg1 io.Reader) error {
	fake.streamToRemoteMutex.Lock()
	ret, specificReturn := fake.streamToRemoteReturnsOnCall[len(fake.streamToRemoteArgsForCall)]
	fake.streamToRemoteArgsForCall = append(fake.streamToRemoteArgsForCall, struct {
		arg1 io.Reader
	}{arg1})
	fake.recordInvocation("StreamToRemote", []interface{}{arg1})
	fake.streamToRemoteMutex.Unlock()
	if fake.StreamToRemoteStub != nil {
		return fake.StreamToRemoteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.streamToRemoteReturns.result1
}

func (fake *FakeBackupBlob) StreamToRemoteCallCount() int {
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	return len(fake.streamToRemoteArgsForCall)
}

func (fake *FakeBackupBlob) StreamToRemoteArgsForCall(i int) io.Reader {
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	return fake.streamToRemoteArgsForCall[i].arg1
}

func (fake *FakeBackupBlob) StreamToRemoteReturns(result1 error) {
	fake.StreamToRemoteStub = nil
	fake.streamToRemoteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) StreamToRemoteReturnsOnCall(i int, result1 error) {
	fake.StreamToRemoteStub = nil
	if fake.streamToRemoteReturnsOnCall == nil {
		fake.streamToRemoteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamToRemoteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBackupBlob) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isNamedMutex.RLock()
	defer fake.isNamedMutex.RUnlock()
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	fake.checksumMutex.RLock()
	defer fake.checksumMutex.RUnlock()
	fake.streamFromRemoteMutex.RLock()
	defer fake.streamFromRemoteMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.streamToRemoteMutex.RLock()
	defer fake.streamToRemoteMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeBackupBlob) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orchestrator.BackupBlob = new(FakeBackupBlob)
