// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry-incubator/bosh-backup-and-restore/instance"
)

type FakeRemoteRunner struct {
	ConnectedUsernameStub        func() string
	connectedUsernameMutex       sync.RWMutex
	connectedUsernameArgsForCall []struct{}
	connectedUsernameReturns     struct {
		result1 string
	}
	connectedUsernameReturnsOnCall map[int]struct {
		result1 string
	}
	DirectoryExistsStub        func(dir string) (bool, error)
	directoryExistsMutex       sync.RWMutex
	directoryExistsArgsForCall []struct {
		dir string
	}
	directoryExistsReturns struct {
		result1 bool
		result2 error
	}
	directoryExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RemoveDirectoryStub        func(dir string) error
	removeDirectoryMutex       sync.RWMutex
	removeDirectoryArgsForCall []struct {
		dir string
	}
	removeDirectoryReturns struct {
		result1 error
	}
	removeDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	CompressDirectoryStub        func(directory string, writer io.Writer) error
	compressDirectoryMutex       sync.RWMutex
	compressDirectoryArgsForCall []struct {
		directory string
		writer    io.Writer
	}
	compressDirectoryReturns struct {
		result1 error
	}
	compressDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	CreateDirectoryStub        func(directory string) error
	createDirectoryMutex       sync.RWMutex
	createDirectoryArgsForCall []struct {
		directory string
	}
	createDirectoryReturns struct {
		result1 error
	}
	createDirectoryReturnsOnCall map[int]struct {
		result1 error
	}
	ExtractArchiveStub        func(reader io.Reader, directory string) error
	extractArchiveMutex       sync.RWMutex
	extractArchiveArgsForCall []struct {
		reader    io.Reader
		directory string
	}
	extractArchiveReturns struct {
		result1 error
	}
	extractArchiveReturnsOnCall map[int]struct {
		result1 error
	}
	SizeOfStub        func(path string) (string, error)
	sizeOfMutex       sync.RWMutex
	sizeOfArgsForCall []struct {
		path string
	}
	sizeOfReturns struct {
		result1 string
		result2 error
	}
	sizeOfReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ChecksumDirectoryStub        func(path string) (map[string]string, error)
	checksumDirectoryMutex       sync.RWMutex
	checksumDirectoryArgsForCall []struct {
		path string
	}
	checksumDirectoryReturns struct {
		result1 map[string]string
		result2 error
	}
	checksumDirectoryReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	RunScriptStub        func(path string) (string, error)
	runScriptMutex       sync.RWMutex
	runScriptArgsForCall []struct {
		path string
	}
	runScriptReturns struct {
		result1 string
		result2 error
	}
	runScriptReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	RunScriptWithEnvStub        func(path string, env map[string]string) (string, error)
	runScriptWithEnvMutex       sync.RWMutex
	runScriptWithEnvArgsForCall []struct {
		path string
		env  map[string]string
	}
	runScriptWithEnvReturns struct {
		result1 string
		result2 error
	}
	runScriptWithEnvReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FindFilesStub        func(pattern string) ([]string, error)
	findFilesMutex       sync.RWMutex
	findFilesArgsForCall []struct {
		pattern string
	}
	findFilesReturns struct {
		result1 []string
		result2 error
	}
	findFilesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRemoteRunner) ConnectedUsername() string {
	fake.connectedUsernameMutex.Lock()
	ret, specificReturn := fake.connectedUsernameReturnsOnCall[len(fake.connectedUsernameArgsForCall)]
	fake.connectedUsernameArgsForCall = append(fake.connectedUsernameArgsForCall, struct{}{})
	fake.recordInvocation("ConnectedUsername", []interface{}{})
	fake.connectedUsernameMutex.Unlock()
	if fake.ConnectedUsernameStub != nil {
		return fake.ConnectedUsernameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.connectedUsernameReturns.result1
}

func (fake *FakeRemoteRunner) ConnectedUsernameCallCount() int {
	fake.connectedUsernameMutex.RLock()
	defer fake.connectedUsernameMutex.RUnlock()
	return len(fake.connectedUsernameArgsForCall)
}

func (fake *FakeRemoteRunner) ConnectedUsernameReturns(result1 string) {
	fake.ConnectedUsernameStub = nil
	fake.connectedUsernameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRemoteRunner) ConnectedUsernameReturnsOnCall(i int, result1 string) {
	fake.ConnectedUsernameStub = nil
	if fake.connectedUsernameReturnsOnCall == nil {
		fake.connectedUsernameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.connectedUsernameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRemoteRunner) DirectoryExists(dir string) (bool, error) {
	fake.directoryExistsMutex.Lock()
	ret, specificReturn := fake.directoryExistsReturnsOnCall[len(fake.directoryExistsArgsForCall)]
	fake.directoryExistsArgsForCall = append(fake.directoryExistsArgsForCall, struct {
		dir string
	}{dir})
	fake.recordInvocation("DirectoryExists", []interface{}{dir})
	fake.directoryExistsMutex.Unlock()
	if fake.DirectoryExistsStub != nil {
		return fake.DirectoryExistsStub(dir)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.directoryExistsReturns.result1, fake.directoryExistsReturns.result2
}

func (fake *FakeRemoteRunner) DirectoryExistsCallCount() int {
	fake.directoryExistsMutex.RLock()
	defer fake.directoryExistsMutex.RUnlock()
	return len(fake.directoryExistsArgsForCall)
}

func (fake *FakeRemoteRunner) DirectoryExistsArgsForCall(i int) string {
	fake.directoryExistsMutex.RLock()
	defer fake.directoryExistsMutex.RUnlock()
	return fake.directoryExistsArgsForCall[i].dir
}

func (fake *FakeRemoteRunner) DirectoryExistsReturns(result1 bool, result2 error) {
	fake.DirectoryExistsStub = nil
	fake.directoryExistsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) DirectoryExistsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.DirectoryExistsStub = nil
	if fake.directoryExistsReturnsOnCall == nil {
		fake.directoryExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.directoryExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) RemoveDirectory(dir string) error {
	fake.removeDirectoryMutex.Lock()
	ret, specificReturn := fake.removeDirectoryReturnsOnCall[len(fake.removeDirectoryArgsForCall)]
	fake.removeDirectoryArgsForCall = append(fake.removeDirectoryArgsForCall, struct {
		dir string
	}{dir})
	fake.recordInvocation("RemoveDirectory", []interface{}{dir})
	fake.removeDirectoryMutex.Unlock()
	if fake.RemoveDirectoryStub != nil {
		return fake.RemoveDirectoryStub(dir)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeDirectoryReturns.result1
}

func (fake *FakeRemoteRunner) RemoveDirectoryCallCount() int {
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	return len(fake.removeDirectoryArgsForCall)
}

func (fake *FakeRemoteRunner) RemoveDirectoryArgsForCall(i int) string {
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	return fake.removeDirectoryArgsForCall[i].dir
}

func (fake *FakeRemoteRunner) RemoveDirectoryReturns(result1 error) {
	fake.RemoveDirectoryStub = nil
	fake.removeDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) RemoveDirectoryReturnsOnCall(i int, result1 error) {
	fake.RemoveDirectoryStub = nil
	if fake.removeDirectoryReturnsOnCall == nil {
		fake.removeDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) CompressDirectory(directory string, writer io.Writer) error {
	fake.compressDirectoryMutex.Lock()
	ret, specificReturn := fake.compressDirectoryReturnsOnCall[len(fake.compressDirectoryArgsForCall)]
	fake.compressDirectoryArgsForCall = append(fake.compressDirectoryArgsForCall, struct {
		directory string
		writer    io.Writer
	}{directory, writer})
	fake.recordInvocation("CompressDirectory", []interface{}{directory, writer})
	fake.compressDirectoryMutex.Unlock()
	if fake.CompressDirectoryStub != nil {
		return fake.CompressDirectoryStub(directory, writer)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.compressDirectoryReturns.result1
}

func (fake *FakeRemoteRunner) CompressDirectoryCallCount() int {
	fake.compressDirectoryMutex.RLock()
	defer fake.compressDirectoryMutex.RUnlock()
	return len(fake.compressDirectoryArgsForCall)
}

func (fake *FakeRemoteRunner) CompressDirectoryArgsForCall(i int) (string, io.Writer) {
	fake.compressDirectoryMutex.RLock()
	defer fake.compressDirectoryMutex.RUnlock()
	return fake.compressDirectoryArgsForCall[i].directory, fake.compressDirectoryArgsForCall[i].writer
}

func (fake *FakeRemoteRunner) CompressDirectoryReturns(result1 error) {
	fake.CompressDirectoryStub = nil
	fake.compressDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) CompressDirectoryReturnsOnCall(i int, result1 error) {
	fake.CompressDirectoryStub = nil
	if fake.compressDirectoryReturnsOnCall == nil {
		fake.compressDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.compressDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) CreateDirectory(directory string) error {
	fake.createDirectoryMutex.Lock()
	ret, specificReturn := fake.createDirectoryReturnsOnCall[len(fake.createDirectoryArgsForCall)]
	fake.createDirectoryArgsForCall = append(fake.createDirectoryArgsForCall, struct {
		directory string
	}{directory})
	fake.recordInvocation("CreateDirectory", []interface{}{directory})
	fake.createDirectoryMutex.Unlock()
	if fake.CreateDirectoryStub != nil {
		return fake.CreateDirectoryStub(directory)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createDirectoryReturns.result1
}

func (fake *FakeRemoteRunner) CreateDirectoryCallCount() int {
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	return len(fake.createDirectoryArgsForCall)
}

func (fake *FakeRemoteRunner) CreateDirectoryArgsForCall(i int) string {
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	return fake.createDirectoryArgsForCall[i].directory
}

func (fake *FakeRemoteRunner) CreateDirectoryReturns(result1 error) {
	fake.CreateDirectoryStub = nil
	fake.createDirectoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) CreateDirectoryReturnsOnCall(i int, result1 error) {
	fake.CreateDirectoryStub = nil
	if fake.createDirectoryReturnsOnCall == nil {
		fake.createDirectoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createDirectoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) ExtractArchive(reader io.Reader, directory string) error {
	fake.extractArchiveMutex.Lock()
	ret, specificReturn := fake.extractArchiveReturnsOnCall[len(fake.extractArchiveArgsForCall)]
	fake.extractArchiveArgsForCall = append(fake.extractArchiveArgsForCall, struct {
		reader    io.Reader
		directory string
	}{reader, directory})
	fake.recordInvocation("ExtractArchive", []interface{}{reader, directory})
	fake.extractArchiveMutex.Unlock()
	if fake.ExtractArchiveStub != nil {
		return fake.ExtractArchiveStub(reader, directory)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.extractArchiveReturns.result1
}

func (fake *FakeRemoteRunner) ExtractArchiveCallCount() int {
	fake.extractArchiveMutex.RLock()
	defer fake.extractArchiveMutex.RUnlock()
	return len(fake.extractArchiveArgsForCall)
}

func (fake *FakeRemoteRunner) ExtractArchiveArgsForCall(i int) (io.Reader, string) {
	fake.extractArchiveMutex.RLock()
	defer fake.extractArchiveMutex.RUnlock()
	return fake.extractArchiveArgsForCall[i].reader, fake.extractArchiveArgsForCall[i].directory
}

func (fake *FakeRemoteRunner) ExtractArchiveReturns(result1 error) {
	fake.ExtractArchiveStub = nil
	fake.extractArchiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) ExtractArchiveReturnsOnCall(i int, result1 error) {
	fake.ExtractArchiveStub = nil
	if fake.extractArchiveReturnsOnCall == nil {
		fake.extractArchiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.extractArchiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRemoteRunner) SizeOf(path string) (string, error) {
	fake.sizeOfMutex.Lock()
	ret, specificReturn := fake.sizeOfReturnsOnCall[len(fake.sizeOfArgsForCall)]
	fake.sizeOfArgsForCall = append(fake.sizeOfArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("SizeOf", []interface{}{path})
	fake.sizeOfMutex.Unlock()
	if fake.SizeOfStub != nil {
		return fake.SizeOfStub(path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.sizeOfReturns.result1, fake.sizeOfReturns.result2
}

func (fake *FakeRemoteRunner) SizeOfCallCount() int {
	fake.sizeOfMutex.RLock()
	defer fake.sizeOfMutex.RUnlock()
	return len(fake.sizeOfArgsForCall)
}

func (fake *FakeRemoteRunner) SizeOfArgsForCall(i int) string {
	fake.sizeOfMutex.RLock()
	defer fake.sizeOfMutex.RUnlock()
	return fake.sizeOfArgsForCall[i].path
}

func (fake *FakeRemoteRunner) SizeOfReturns(result1 string, result2 error) {
	fake.SizeOfStub = nil
	fake.sizeOfReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) SizeOfReturnsOnCall(i int, result1 string, result2 error) {
	fake.SizeOfStub = nil
	if fake.sizeOfReturnsOnCall == nil {
		fake.sizeOfReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.sizeOfReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) ChecksumDirectory(path string) (map[string]string, error) {
	fake.checksumDirectoryMutex.Lock()
	ret, specificReturn := fake.checksumDirectoryReturnsOnCall[len(fake.checksumDirectoryArgsForCall)]
	fake.checksumDirectoryArgsForCall = append(fake.checksumDirectoryArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("ChecksumDirectory", []interface{}{path})
	fake.checksumDirectoryMutex.Unlock()
	if fake.ChecksumDirectoryStub != nil {
		return fake.ChecksumDirectoryStub(path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checksumDirectoryReturns.result1, fake.checksumDirectoryReturns.result2
}

func (fake *FakeRemoteRunner) ChecksumDirectoryCallCount() int {
	fake.checksumDirectoryMutex.RLock()
	defer fake.checksumDirectoryMutex.RUnlock()
	return len(fake.checksumDirectoryArgsForCall)
}

func (fake *FakeRemoteRunner) ChecksumDirectoryArgsForCall(i int) string {
	fake.checksumDirectoryMutex.RLock()
	defer fake.checksumDirectoryMutex.RUnlock()
	return fake.checksumDirectoryArgsForCall[i].path
}

func (fake *FakeRemoteRunner) ChecksumDirectoryReturns(result1 map[string]string, result2 error) {
	fake.ChecksumDirectoryStub = nil
	fake.checksumDirectoryReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) ChecksumDirectoryReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.ChecksumDirectoryStub = nil
	if fake.checksumDirectoryReturnsOnCall == nil {
		fake.checksumDirectoryReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.checksumDirectoryReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) RunScript(path string) (string, error) {
	fake.runScriptMutex.Lock()
	ret, specificReturn := fake.runScriptReturnsOnCall[len(fake.runScriptArgsForCall)]
	fake.runScriptArgsForCall = append(fake.runScriptArgsForCall, struct {
		path string
	}{path})
	fake.recordInvocation("RunScript", []interface{}{path})
	fake.runScriptMutex.Unlock()
	if fake.RunScriptStub != nil {
		return fake.RunScriptStub(path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runScriptReturns.result1, fake.runScriptReturns.result2
}

func (fake *FakeRemoteRunner) RunScriptCallCount() int {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	return len(fake.runScriptArgsForCall)
}

func (fake *FakeRemoteRunner) RunScriptArgsForCall(i int) string {
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	return fake.runScriptArgsForCall[i].path
}

func (fake *FakeRemoteRunner) RunScriptReturns(result1 string, result2 error) {
	fake.RunScriptStub = nil
	fake.runScriptReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) RunScriptReturnsOnCall(i int, result1 string, result2 error) {
	fake.RunScriptStub = nil
	if fake.runScriptReturnsOnCall == nil {
		fake.runScriptReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runScriptReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) RunScriptWithEnv(path string, env map[string]string) (string, error) {
	fake.runScriptWithEnvMutex.Lock()
	ret, specificReturn := fake.runScriptWithEnvReturnsOnCall[len(fake.runScriptWithEnvArgsForCall)]
	fake.runScriptWithEnvArgsForCall = append(fake.runScriptWithEnvArgsForCall, struct {
		path string
		env  map[string]string
	}{path, env})
	fake.recordInvocation("RunScriptWithEnv", []interface{}{path, env})
	fake.runScriptWithEnvMutex.Unlock()
	if fake.RunScriptWithEnvStub != nil {
		return fake.RunScriptWithEnvStub(path, env)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runScriptWithEnvReturns.result1, fake.runScriptWithEnvReturns.result2
}

func (fake *FakeRemoteRunner) RunScriptWithEnvCallCount() int {
	fake.runScriptWithEnvMutex.RLock()
	defer fake.runScriptWithEnvMutex.RUnlock()
	return len(fake.runScriptWithEnvArgsForCall)
}

func (fake *FakeRemoteRunner) RunScriptWithEnvArgsForCall(i int) (string, map[string]string) {
	fake.runScriptWithEnvMutex.RLock()
	defer fake.runScriptWithEnvMutex.RUnlock()
	return fake.runScriptWithEnvArgsForCall[i].path, fake.runScriptWithEnvArgsForCall[i].env
}

func (fake *FakeRemoteRunner) RunScriptWithEnvReturns(result1 string, result2 error) {
	fake.RunScriptWithEnvStub = nil
	fake.runScriptWithEnvReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) RunScriptWithEnvReturnsOnCall(i int, result1 string, result2 error) {
	fake.RunScriptWithEnvStub = nil
	if fake.runScriptWithEnvReturnsOnCall == nil {
		fake.runScriptWithEnvReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.runScriptWithEnvReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) FindFiles(pattern string) ([]string, error) {
	fake.findFilesMutex.Lock()
	ret, specificReturn := fake.findFilesReturnsOnCall[len(fake.findFilesArgsForCall)]
	fake.findFilesArgsForCall = append(fake.findFilesArgsForCall, struct {
		pattern string
	}{pattern})
	fake.recordInvocation("FindFiles", []interface{}{pattern})
	fake.findFilesMutex.Unlock()
	if fake.FindFilesStub != nil {
		return fake.FindFilesStub(pattern)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findFilesReturns.result1, fake.findFilesReturns.result2
}

func (fake *FakeRemoteRunner) FindFilesCallCount() int {
	fake.findFilesMutex.RLock()
	defer fake.findFilesMutex.RUnlock()
	return len(fake.findFilesArgsForCall)
}

func (fake *FakeRemoteRunner) FindFilesArgsForCall(i int) string {
	fake.findFilesMutex.RLock()
	defer fake.findFilesMutex.RUnlock()
	return fake.findFilesArgsForCall[i].pattern
}

func (fake *FakeRemoteRunner) FindFilesReturns(result1 []string, result2 error) {
	fake.FindFilesStub = nil
	fake.findFilesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) FindFilesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.FindFilesStub = nil
	if fake.findFilesReturnsOnCall == nil {
		fake.findFilesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.findFilesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeRemoteRunner) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.connectedUsernameMutex.RLock()
	defer fake.connectedUsernameMutex.RUnlock()
	fake.directoryExistsMutex.RLock()
	defer fake.directoryExistsMutex.RUnlock()
	fake.removeDirectoryMutex.RLock()
	defer fake.removeDirectoryMutex.RUnlock()
	fake.compressDirectoryMutex.RLock()
	defer fake.compressDirectoryMutex.RUnlock()
	fake.createDirectoryMutex.RLock()
	defer fake.createDirectoryMutex.RUnlock()
	fake.extractArchiveMutex.RLock()
	defer fake.extractArchiveMutex.RUnlock()
	fake.sizeOfMutex.RLock()
	defer fake.sizeOfMutex.RUnlock()
	fake.checksumDirectoryMutex.RLock()
	defer fake.checksumDirectoryMutex.RUnlock()
	fake.runScriptMutex.RLock()
	defer fake.runScriptMutex.RUnlock()
	fake.runScriptWithEnvMutex.RLock()
	defer fake.runScriptWithEnvMutex.RUnlock()
	fake.findFilesMutex.RLock()
	defer fake.findFilesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRemoteRunner) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ instance.RemoteRunner = new(FakeRemoteRunner)
